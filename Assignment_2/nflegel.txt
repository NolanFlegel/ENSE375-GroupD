1.0 Introduction:
	Version control software (VCS) is a family of programs whose goal is to provide a structured way to save and distribute iterations of a software project. The use of a VCS can improve ease of collaboration, efficiency in workflow, and recovery from bugs and security threats. Collaboration is made easier by granting all contributors the freedom to view and download the entire project, by seeing how their specific work fits in with the bigger picture motivation tends to be higher and the work produced tends to fit better. Workflow efficiency is improved through a combination of better fitting code and the concept of conflict resolution and automated merging of code. Advantages in recovery from bugs and security issues come from the fact that it is so easy to go back a version if something opens up an exploit or breaks something in the code. VCS’ have a lot of upside and should be considered for use in most projects.

	Git is a popular VCS which uses concurrent versioning (CS) to accomplish its purpose. There are a great deal of aspects which are valuable to examine to both understand the applicability of VCS’ and Git, these include the history of source control, the toolkit, branching, merging, conflict resolution, and extensibility. This paper will discuss these topics and more in detail to present the functionality of Git as well as VCS concepts.	
2.0 History of Source Control
Source control originated in 1975 with a system called Source Code Control System (SCCS). The objective was to provide a simplistic method of saving source code files without creating many copies of the same file. It worked by saving the changes made to the file, also known as Deltas. In 1982 a new system was developed, known as the Revision Control System (RCS). It was an evolution of the SCCS, adding a few more useful features. RCS was free and maintained by the GNU project, this led to it becoming a popular alternative to SCCS.

While useful, these early source control systems had their limitations. Only one developer could work on a file at the same time, publishing changes required a strict hierarchy of versions and required a shared file system. In 1986 a new system was developed to address these issues, the Concurrent Versioning System (CVS). It brought forth a host of new changes, primarily the ability for developers to simultaneously edit the same file and a mechanism to resolve differences between edits. CVS also introduced the idea of code branching, allowing developers to work on multiple tasks at the same time. Lastly, CVS allowed the code repository to work across large networks using a client-server architecture. These early systems created the foundations for some of the latest and current systems like Subversion, Git and Mercurial. 

The first of the modern systems was Subversion, created in 2000. Subversion sought to solve existing problems in CVS by creating a new control system that focused on entire code branches and local copies of the repository. Like its predecessors, Subversion maintained a centralized repository, where a central computer tracks all of the code changes. Following Subversion in 2005 would be Mercurial and Git, created by linux developers Matt Mackall and Linus Tovalds, respectively. 

Modern source control systems follow a typical process of getting the latest version of files, make changes to that version and publish the changes so other developers can access them. While these new systems share features of their predecessors, they have continued to refine the process and solved many problems that early code control systems encountered. Both platforms sought to solve the issue of distributed version control where temporal tracking of changes is not ideal. 
3.0 Distribution
	Centralized systems require network connections to the repository server for any code changes to be made. This method ensures that no changes are lost, however in large organizations this can make accessing the repository slow. Centralized systems have difficulty tracking merges because committing and publishing code changes are inherently the same process with this system. The benefit of controlling the source code with a single server is a simplified integration process and a strict hierarchy of revisions. While Subversion uses a centralized system for version control, Git and Mercurial have implemented a distributed version control method as a way to address the problems with centralized systems. 

In distributed systems, developers can work on their local system and maintain separate code repositories. They do not require an active connection to a central repository. This key difference allows developers to incrementally commit their work locally until they are ready to share their changes with others. As a result, accessing and making edits to code is much faster and merging files is easier to track. These systems can manage a significantly larger number of changes and files than existing centralized systems. This method of simultaneous changes makes it impossible to track revisions temporally. The directed graph in Figure 1, illustrates their solution where changes become children of the revision it was based on. 
-----------------------------------------------
9.0 Comparison of Use Cases
Git and Mercurial share many of the same features and qualities. These versioning systems were created around the same time, for the same purpose: managing the linux kernel repository. Both systems offer distributed repositories, code branching, version histories, extensibility and both use a directed graph data structure. The differences between Git and Mercurial begin with how these features were implemented and the overall popularity of the platforms. 

	Mercurial is easier to learn, the commands are simple and only have one purpose. The embedded documentation is clear and comprehensive, developers are able to easily find commands and understand how to use them. Mercurial’s history is permanent and cannot be edited, this prevents any accidental deletions. 

	Git commands are more complex and offer greater flexibility. Individual commands have additional options that provide different functionality to the base command. As a result Git is more difficult to learn, however leads to more features for developers. Git’s version history differs from Mercurial by allowing developers to edit previous commits and reorder the version history. This functionality provides developers with greater control over the repository while enabling the possibility for unintentional deletions. Recovery from deletions is possible in Git as all changes are tracked, however requires the use of an additional command. The increased functionality of Git also increases the complexity. It is important for developers to have a greater understanding of the commands because misuse can have unintended consequences.

	Git has been widely adopted by developers and organizations. While Mercurial has less mainstream recognition, it is regularly maintained and used by many organizations. In recent years, Git has become the industry standard version control system. As a result there are more extensions and plugins available and more tutorials and support for Git. Both platforms are powerful, modern version control systems that offer complete tool sets for developers and organizations. Git is more accessible due to wider adoption and offers a robust set of features and greater control to developers. 
